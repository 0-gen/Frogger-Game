# Final Project: Frogger  
**EE379 Spring 2019**  
University at Buffalo, The State University at New York  

---

The information enclosed in this document and the source code generated for this laboratory assignment were generated by the named students on this cover page. Detection of plagiarism in a submitted lab or project design document will result in an automatic failing grade in the course by all parties involved.

**Written By**  
Christopher Fritz  
**Engineer**  
Brandyn Myrick  
**Engineer**  
Eugen Feng

**Revision History**  
| Rev  | Date   | Session    | Approved/Grade |
|------|--------|------------|----------------|
| Orig | 5/1/19 | Tues. 3PM  |                |

**Teaching Assistant**  
Lalit Kishore Marepalli

**Group**  
6

**Course**  
EE379S19

---

## Table of Contents
1. [Introduction](#introduction)  
    1.1 [Overview](#overview)  
    1.2 [Scope](#scope)  
    1.3 [Intended Audience](#intended-audience)  
2. [Code](#code)  
    2.1 [Hardcoding Dimensions](#hardcoding-dimensions)  
    2.2 [Drawing Cars and Trucks](#drawing-cars-and-trucks)  
    2.3 [Moving Cars/Trucks](#moving-carstrucks)  
    2.4 [Draw Frog](#draw-frog)  
    2.5 [Joystick](#joystick)  
    2.6 [Draw and Move Logs and Turtles](#draw-and-move-logs-and-turtles)  
    2.7 [Boundaries](#boundaries)  
    2.8 [Collision](#collision)  
    2.9 [Lives](#lives)  
    2.10 [Extra Credit](#extra-credit)  
3. [Explanation](#explanation)  
    3.1 [Hardcoding Dimensions](#explanation-hardcoding-dimensions)  
    3.2 [Drawing Cars and Trucks](#explanation-drawing-cars-and-trucks)  
    3.3 [Moving Cars/Trucks](#explanation-moving-carstrucks)  
    3.4 [Draw Frog](#explanation-draw-frog)  
    3.5 [Joystick](#explanation-joystick)  
    3.6 [Draw and Move Logs and Turtles](#explanation-draw-and-move-logs-and-turtles)  
    3.7 [Boundaries](#explanation-boundaries)  
    3.8 [Collision](#explanation-collision)  
    3.9 [Lives](#explanation-lives)  
    3.10 [Extra Credit](#explanation-extra-credit)  

## 1. Introduction  
### 1.1 Overview  
For this project, we will recreate the classic video game Frogger using the Landtiger NXP LPC1768 board. We will code in C and communicate our software to the board through a U-link wired connection.

### 1.2 Scope  
The purpose of this is to understand low-level coding and implementation. This is known as an embedded system. We will implement our code onto a hardware interface after programming the software needed to meet the requirements of the system.

### 1.3 Intended Audience  
The intended audience of this project would be those interested in implementing an embedded system themselves and applying it to the real world, such as our colleagues in electrical engineering. The viewers will also include our teaching assistants and the professor overseeing our progress throughout this project.

## 2. Code  
See Frogger.c

## 3. Explanation  
### 3.1 Hardcoding Dimensions  
To create the game board and the scoreboard, each x and y positions for all the entities
and background color was predetermined. The background was worked on first to visually
separate the game board from the scoreboard. Then we separated the water, grass, home, and
roads from each other to be able to call the vehicles and logs and turtles functions so they move.
To learn the dimensions of the gameboard is essentially because otherwise the moving entities
might overlap the scoreboard. To prevent this, we had the scoreboard draw itself in the while
loop. Also to note that the order matters, so we put the draw scoreboard after the drawscreen.

### 3.2 Drawing Cars and Trucks  
In order to create the cars, we created functions to draw the cars when the function was
called. For the cars moving from left to right, the parameters cx,cy, width1, and color were given
defined. Cx was used to define its center placement and cy, to define its center height placement.
Then we defined the width, which is also the name of our variable to define the width of 7. The
color parameter was used to draw the car on the screen and also used to remove the old car by
changing the color from black to red. The process of this occurring is discussed in Section 3.3.
Cx was used in a for loop to draw the length of the car, we also incremented the value of the
height, cy, also used in a for loop to create the same exact car two more times above the previous
ones. There are multiple drawcar functions because they represent the cars and trucks and the
number of cars in the row.

### 3.3 Moving Cars/Trucks  
The function would be called by the main function and draw a black car on top of our
black background. Then cx would increment by 1 pixel and overdrawn as a red car. Same with
the trucks, they will be drawn first in black then drawn in purple. They will keep drawing until
they hit the boundary of the game, and reset back to the other side of the screen. This will
continue to happen until the game is lost or won. Along with the moving vehicles, they also have
a collision code that if a frog ever touches either of these entities, the frog will be sent back to its
original position at the bottom of the screen (Frog dies). This is done by checking to see when
the frog is in an Y-axis that could cause the frog to die. If that frog is in that y-axis, have it check
to see if the corners of the frog positions is ever within the vehicle’s position or even touching it.
The hitboxes are closely approximate. If the frog touches the vehicle, the frog will be sent back,
or dies in our case.

### 3.4 Draw Frog  
The draw frog is our user defined function of drawing a frog. It consists of using a draw
circle function to draw the body and two eyes. Then we used a for loop with the putpixel
function to manually draw 4 limbs, or 8 rectangles. The putpixel will depend on x0 and y0. We
will change these variables in the main function to move the frog.

### 3.5 Joystick  
Once we are able to draw the frog, we will assign the joystick buttons, their pin values to
match a directional movement. We had to change the original joystick pins for up, down, left and
right, to match our orientation of the game so we can move left to move left and etc. We found
the pin values for the joystick online on the Landtiger LPC board schematic. We check to see if
the button matches an on_val to see if it was pressed. If it was pressed we assign the x0 and y0 of
the frog positions to the directional joystick keys. We made it so if it is pressed, the frog will
move either 18 pixels up/down or 20 pixels right/left. This was done as if the game board was
stored in an mxn array, so the frog will be positioned exactly in the middle of each location.
(Like a chess board).

### 3.6 Draw and Move Logs and Turtles  
Likewise to the moving cars and truck, the logs and turtles are moving along the x-axis of
the game board at a certain determined speed. Which is denoted by padspeed and logspeed. We
did padspeed because initially I thought the turtles were lily pads. However, unlike the cars and
trucks for the collision code, we will not die if we are on these entities and die elsewhere along
these y-axis. There are also multiple turtles and logs functions to draw more entities in the rows
they move along.

### 3.7 Moving Frog with Log
To have the frog move along with the log, we will use the same collision code as for the
cars and trucks. If the frog positions (the 4 corners of the frog) is within the 4 corners of the logs
or turtle positions, or even somewhat on it, have the frog move in a certain axis with either
logspeed or padspeed. So it will go either left or right depending what entity you are standing on.

### 3.8 Boundaries  
The game board boundaries was a simple code in which, if the frog position is ever
greater than or less than the game boundary, reverse that action. In our case if it goes too much to
the left, send the frog right, and etc.

### 3.9 Collision  
The collision is coded by checking to see if the frog’s y0 position is within the
logs/turtles/cars/trucks y-positions. If they are within the y-positions it will check if the frog’s x0
positions +- its size, is within the x-positions of the other moving entities. If it is, the frog will
die by sending it back to the starting position or it will move with the logs/turtles.

### 3.10 Lives  
The lives counter start with the bitwise operator >, which will translate the lives int
parameter into a actual sprite icons. If lives>3 it will display one sprite, lives>2 display another
sprite, etc. This is so it will always display all the sprite and as you lose lives, more sprites will
be gone. They are erased by a constantly refreshing background (constantly being redrawn).
When lives is 0, it will displayString of “You lose”. It will replace the screen with a black screen
and display it.

### 3.11 Extra Credit  
For the extra credits, we gave trucks, turtles, and the frog textures, we implemented a
scoreboard, UART PC controls, and a pause/resume button. For the frog trucks and turtle
textures, we utilized the draw circle functions that was provided and put pixels. We hardcoded
shapes and put them together into one function, so when it is called it will draw all of it. The
scoreboard is done by utilizing the display string and sprintf. The sprintf stores a changing
variable in the displaystring function. The changing variable is dependent on whether or not a
home slot for the frog is filled. If any home slot is filled, add 100 points. This also contributes to
how the game is won, if score equals to 500. For UART PC controls, we set the buffer array to
try to match conditions. If an element in the buffer array matches to a ”, have them perform a
certain action, in our case move the frog up, left , down, and right. The pause/resume button is
done by putting in a if statement to check for a button press and have it enter an infinite loop
until the button is pressed again to resume. I also put in a delay for the button press so it would
not pause and resume upon a button press.

## Glossary  
**Function:** A function can be used to calculate data based on input parameters. In C, there are user-defined functions and also functions that are predefined by the libraries in C. A function can be called by the main function to perform a task from the input parameters given.

**void drawFrog(int x0, int y0, int color):** This, for example is our User-Defined function. This
function was created and is called in order to create an image of a Frog sprite on the GLCD
display. It takes input parramters x0,y0, and color. The main function calls this function and
computes the arithmetic values to draw the frog in a specific area of the screen.

**GLCD_DisplayString():** This function is a library predefined function. It is given in the
software of C. It can be called in any compiler because the library is included. This function is
able to display characters on the screen of 1 size only in an x and y coordinate given the input
characters to be typed.

**GLCD_SetTextColor(Color):** This function calls the GLCD header function that was included
in our lab, this function allows us to color the shape.

**for/while:** These loops can be implemented to perform controlled or infinite amount of
iterations.

**Data type:** This includes int, char, etc. these define the return value and allocate a certain
amount of bits to them.

**|| (OR):** This is a logical operator that is used to compare two parameters and give an output
based on if the logic is true or false. This is seen in our code as conditional statements.

**-> (pointer):** A pointer, which can be seen in our code is used to point to an address and is able
to read the values in that memory address even if the data is private to a specific function or not.
